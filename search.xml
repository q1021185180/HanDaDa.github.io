<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>试水</title>
    <url>/2020/04/06/hexo-frist/</url>
    <content><![CDATA[<h2 id="Java编码规范整理汇总"><a href="#Java编码规范整理汇总" class="headerlink" title="Java编码规范整理汇总"></a>Java编码规范整理汇总</h2><p>在Java的入门过程中，我们首先要养成一个良好的编写代码习惯。那么，了解清楚Java的编码规范就显得尤为必要了。编码格式不仅仅是美不美观的问题。这里我们可以试想一下，如果在Java开发中编码不规范，容易出现bug不说，而且后续还难以维护。因此，遵守编码规范可以让代码的风格好像是一个人写出来的，即使是有很多人参与这个开发项目。</p>
<p>1、源文件基础</p>
<p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 .java。源文件编码格式为UTF-8。除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着所有其它字符串中的空白字符都要进行转义；制表符不用于缩进。对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如 \012)或Unicode(比如 \u000a)转义。对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>
<p>2、源文件结构</p>
<p>一个源文件包含(按顺序地)：许可证或版权信息；package语句；import语句；一个顶级类。以上每个部分之间用一个空行隔开。如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。package语句不换行，列限制(4.4节)并不适用于package语句。import不要使用通配符，不要换行。</p>
<p>3、格式</p>
<p>大括号与 if,else,for,do,while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格，左大括号前不换行；左大括号后换行；右大括号前换行；如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。一个空的块状结构里什么也不包含，大括号可以简洁地写成 {}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。</p>
<p>4、空白</p>
<p>以下情况需要使用一个空行：类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块；在函数体内，语句的逻辑分组间使用空行；类内的第一个成员前或最后一个成员后的空行是可选；要满足本文档中其他节的空行要求。除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：分隔任何保留字与紧随其后的左括号( ()(如 if,forcatch等)；分隔任何保留字与其前面的右大括号( })(如 else,catch)等等。</p>
<p>5、命名约定</p>
<p>对所有标识符都通用的规则，标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式 \w+。类名都以 UpperCamelCase风格编写，方法名都以 lowerCamelCase风格编写；常量名命名模式为 CONSTANT_CASE，全部字母大写，用下划线分隔单词；非常量字段名以 lowerCamelCase风格编写；参数名以 lowerCamelCase风格编写；比起其它类型的名称，局部变量名可以有更为宽松的缩写。、</p>
<p>6、编程实践</p>
<p>只要是合法的，就把 @override注解给用上。使用类名调用静态的类成员，而不是具体某个对象或表达式。极少会去重写 Object.finalize。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>unity游戏开发术语</title>
    <url>/2020/04/07/unity/</url>
    <content><![CDATA[<p>16毫秒 / 帧速率<br>Frame Rate。</p>
<p>电子游戏使用的光栅显示器是普通电视时，图像一般每秒更新60次。图像更新的时间叫做帧，1秒60次即1次16毫秒（0.0167秒 = 16.7毫秒）。</p>
<p>16毫秒是玩家可以识别的游戏画面改变的最短时间间隔。</p>
<p>ARPG<br>Action Role Playing Game。</p>
<p>角色扮演类游戏中动作性较强的实时游戏，也指包含冒险游戏特征的游戏。</p>
<p>bot<br>外挂。模拟游戏玩家自动访问游戏服务器、高效率地进行游戏、积累分数以及进行恶意的经济欺诈的程序。</p>
<p>测试外挂是指开发者准备的用来自动化测试的客户端程序。</p>
<p>CPU周期<br>CPU Cycle。</p>
<p>CPU处理操作的最小单位。1GHz的CPU一秒有10亿个CPU周期，以执行的命令数而言，1秒可以执行10亿次。</p>
<p>根据命令类型的不同，执行需要的CPU周期少则不到1个周期，多则有几百个。</p>
<p>FPS<br>First-Person Shooter。</p>
<p>第一人称射击游戏。</p>
<p>I / O<br>Input / Output。</p>
<p>输入 / 输出。包括网络 I / O、磁盘 I / O等。服务器程序的I / O基本都是网络I / O。</p>
<p>MMO<br>Massively Multiplayer Online。</p>
<p>大型多人网络游戏。也叫MMOG。</p>
<p>MO<br>多人网络游戏。也叫MOG。</p>
<p>RPC<br>Remote Procedure Call。</p>
<p>远程过程调用，是指调用其他计算机的处理。</p>
<p>例如，当客户端需要命令服务器做某个处理然后得到返回结果时会使用该技术。</p>
<p>RPG<br>Role Playing Game。</p>
<p>角色扮演游戏，根据游戏背景设定，由玩家扮演特定角色的游戏。</p>
<p>TCP<br>Transport Control Protocol。</p>
<p>传输控制协议，支撑整个互联网的可靠数据通信协议。可以根据需要续传IP的数据包，确保大的数据可以正常传输。但是，在连接速度较慢时，为了提高传输效率需要占用大量的内存。</p>
<p>并行<br>Parallel。</p>
<p>包括物理上的多个处理同时进行，以及时间上的并发（Concurrent）处理。就像CPU中的命令和任务之间的区别。通过并行处理提高速度比较困难，所以基本方针是充分考虑处理器计算能力，通过在策划层次进行讨论，或者在算法上下功夫减少计算量。</p>
<p>部署<br>Deploy。</p>
<p>是指部署应用程序。服务器部署是指将最新版服务器程序安装到各个服务器上来更新版本的相关操作。</p>
<p>持久性<br>Persistent。</p>
<p>在数据库中，持久性是指需要持久化的时间长度，包括游戏玩法中必要的时间和游戏进行所需的时间。竞速游戏的数据一般只需要保持几分钟，之后就可以丢弃，所以持久性较低，需要保存的数据量也比较小，但是MMORPG等不断进行的游戏需要较高持久性，数据量也比较大。根据持久性需求的不同，数据应该以什么形式、用什么物理介质来保存也会有所区别。</p>
<p>带宽<br>Bandwidth。</p>
<p>是指网络传输数据的传输速率。也叫带宽幅度。</p>
<p>多进程编程<br>Multi-Process Programming。</p>
<p>灵活使用多个进程的编程方式。同时运行多个进程可以有效利用多核CPU的处理能力。</p>
<p>辅助系统<br>Additonal System。</p>
<p>相对于游戏主体内容以外的辅助功能系统，例如玩家匹配、玩家成绩管理（积分管理）、排名以及通信功能等。</p>
<p>多数情况下可以使用第三方的程序或者服务。</p>
<p>负荷<br>Load。</p>
<p>是指CPU或者网络等承载的工作量。例如，处理复杂计算时CPU的负荷比较高。发送和接收大量数据时网络的负荷较高。许多场合都可以使用，例如CPU负荷、I/O负荷以及服务器负荷等。</p>
<p>负载均衡<br>Load Balancing。</p>
<p>是指分散负荷。例如将一台数据库承担的负荷分散到多台数据库。</p>
<p>共享内存<br>Shared Memory。</p>
<p>是指在多个进程间共享内存数据。例如共享运动物体的坐标、种类以及运动方向等信息。</p>
<p>缓存<br>Cache。</p>
<p>为了高速读取数据而把数据暂时放在特殊区域。</p>
<p>例如，磁盘访问比较慢时，可以把文件内容放在（缓存在）内存中，这样就可以高速读取数据。</p>
<p>该机制被广泛应用在CPU缓存、缓存内存、浏览器缓存以及缓存服务器等地方。</p>
<p>进程<br>Process。</p>
<p>进程是指操作系统运行的程序的实体，和其他程序相分离，独立运行。进程与进程之间可以访问的资源（内存、Socket等）也是分离的。</p>
<p>进程间通信<br>Inter-Process Communication。</p>
<p>在多个进程间通信。是指多个进程间传送数据或共享数据的技术。</p>
<p>竞态条件<br>Race Condition。</p>
<p>是指同一个资源（内存地址等）被两个以上的使用者访问时发生的程序状态。会引起死锁（Dead Lock，互相等待对方处理结果的情况）等问题。</p>
<p>扩展性<br>Scalable。</p>
<p>是指可以扩展系统性能。</p>
<p>在网络游戏中需要应对用户的增长和饱和，所以希望性能和功能可以轻松扩展。</p>
<p>浏览器<br>Browser。</p>
<p>浏览软件。网络游戏中的游戏浏览器范围较广，泛指将服务器网站管理的游戏进度信息展示给玩家的软件。</p>
<p>例如使用C++语言开发的面向3D游戏的专用程序，或者Flash游戏使用的Google Chrome等Web浏览器。和一般浏览Web服务器数据的Web浏览器有所区别。</p>
<p>轮询<br>Polling。</p>
<p>定期询问数据是否送达或者是否接收到的机制。太过频繁的轮询会无端增加CPU的负荷。</p>
<p>瓶颈<br>Bottleneck。</p>
<p>系统中性能最弱的部分。系统的其他部分即使再快，如果有一个地方（瓶颈）处理比较慢，就会影响整体的性能。</p>
<p>冗余<br>Redumdancy。</p>
<p>作为预备而重复配置。</p>
<p>游戏数据的冗余是指将数据在不同地方重复保存（主数据和备份数据的关系）。</p>
<p>事件驱动<br>Event Driven。</p>
<p>在事件发生时进行处理的编程方式。事件的类型包括接收到数据、鼠标移动等。事件驱动的编程方式常用在网络开发和游戏开发中。</p>
<p>数据包<br>Packet。</p>
<p>数据的传输单位。数据包通信是指将数据分割并添加控制信息后发送、接收后再合并的通信方式。TCP协议的数据通信单位是数据段（Segment），UDP/IP协议为数据报（Datagram）。网络游戏开发会经常面临数据包延迟的挑战。</p>
<p>数据中心<br>Data Center。</p>
<p>安置提供服务的服务器设施。配备了维持服务器所必需的电源、空调和防灾设施。</p>
<p>套接字 API<br>Socket API。</p>
<p>处理网络文件描述符中的套接字 API。个别的函数/系统调用（socket、connect、accept）。</p>
<p>同时连接数<br>可以同时连接服务的用户数。</p>
<p>图元<br>Sprite。</p>
<p>是指电子游戏中使用的可以告诉显示的小图像。事先准备好玩家角色移动等状态的小图片，可以通过指定图像位置，在画面的任意位置显示角色。</p>
<p>吞吐量<br>Throughput</p>
<p>系统在一定时间内处理的数量。</p>
<p>网络拓扑<br>网络中所含的各个计算机以什么结构相连接。计算机是节点，连接叫做边界。包括星状结构、总线结构和网状结构等，可以帮助分析和设计网络结构。</p>
<p>文件描述符<br>在Unix系的操作系统中，除了文件以外，网络、块设备等操作系统管理的输入输出资源也采用了文件形式。</p>
<p>线程<br>Thread。</p>
<p>比进程更细分的程序执行单位。</p>
<p>延迟<br>处理所需要的时间。</p>
<p>游戏客户端<br>Game Client。</p>
<p>指玩家的PC或者游戏机等机器上安装的，启动后可以显示游戏画面、接受用户输入输出的软件。</p>
<p>游戏逻辑<br>Game Logic</p>
<p>指连接游戏进度信息和用户界面信息的算法。</p>
<p>云（Cloud）<br>在云计算中主要是指服务器端的计算机群。</p>
<p>在单纯的主机托管中，包括存储、负载均衡、付费系统、日志解析等服务器架构中的计算机资源可以根据需要即时调整。</p>
<p>在内存中<br>把数据放在内存中，可以在几个CPU时钟周期（几纳秒到几百纳秒之间）获取到数据的状态。</p>
<p>中间件<br>Middleware</p>
<p>将应用程序普遍使用的功能进行集成的专业化软件。</p>
<p>纵向扩展 / 横向扩展<br>纵向扩展是指增加内存、升级CPU等，通过提升单台服务器的性能来改善系统性能的方法。</p>
<p>横向扩展是指通过增加服务器台数来提供系统性能的方法。</p>
<p>阻塞/非阻塞<br>阻塞是指处理完成之前持续等待。</p>
<p>例如，收到数据前持续等待的程序（阻塞程序），在等待期间不能进行其他处理。</p>
<p>采用非阻塞（不持续等待）处理可以解决这个问题。也可以叫做同步调用和非同步调用。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
</search>
